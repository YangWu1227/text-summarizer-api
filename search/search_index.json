{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workflows","text":""},{"location":"#environment-setup","title":"Environment Setup","text":""},{"location":"#install-pdm","title":"Install PDM","text":"<p>The dependency manager used in this project is pdm. To install it, run the following command:</p> <pre><code>$ curl -sSL https://pdm-project.org/install-pdm.py | python3 -\n</code></pre> <p>Or, alternatively, other installation methods can be used.</p>"},{"location":"#install-dependencies","title":"Install Dependencies","text":"<p>The dependencies are broken into groups:</p> <ul> <li> <p>Default dependencies: required for the core functionality of the project in production.</p> </li> <li> <p>Development dependencies: required for development, testing, and documentation.</p> </li> </ul> <p>The specified python version in <code>pyproject.toml</code> is <code>&gt;=3.11</code>, and so a python 3.11 interpreter should be used. </p>"},{"location":"#conda","title":"Conda","text":"<p>To do so with conda:</p> <pre><code>$ conda search python | grep \" 3\\.\\(10\\|11\\|12\\)\\.\"\n$ yes | conda create --name text_summarizer_api python=3.11.9\n$ conda activate text_summarizer_api\n$ pdm use -f $(which python3)\n$ pdm install\n</code></pre>"},{"location":"#vitualenv","title":"Vitualenv","text":"<p>To do so with virtualenv, use the pdm venv command:</p> <pre><code>$ pdm venv create --name text_summarizer_api --with virtualenv 3.11.9 \n# To activate the virtual environment\n$ eval $(pdm venv activate text_summarizer_api) \n$ pdm install\n</code></pre>"},{"location":"#docker-compose","title":"Docker Compose","text":"<p>The development environment is set up using Docker Compose. This setup defines two services: </p> <ul> <li> <p>web: sets up the application based on <code>dev.Dockerfile</code>.</p> </li> <li> <p>wev-db: sets up a PostgreSQL database based on <code>db.Dockerfile</code>, which simply Adds a <code>.sql</code> file to the container at <code>/docker-entrypoint-initdb.d/</code>. Two databases are created: <code>web_dev</code> for development and <code>web_test</code> for testing; neither is used in production.</p> </li> </ul>"},{"location":"#build-and-run-the-services","title":"Build and Run the Services","text":"<p>Note: All the commands should be run from the root of the project where <code>docker-compose.yml</code> is located. In addition, Compose V2 is used, so the <code>docker-compose</code> command is replaced with <code>docker compose</code>.</p> <p>To build the images and run the containers in the background:</p> <pre><code>$ docker compose up --detach --build\n</code></pre> <p>Directories such as <code>app/</code>, <code>tests/</code>, <code>migrations/</code>, and the <code>pyproject.toml</code> file are bind-mounted to their respective counterparts in the <code>web</code> service container. This setup allows for automatic reloading of the application when changes are made to the code during development.</p> <p>To stop the containers without removing them:</p> <pre><code>$ docker compose stop\n</code></pre> <p>To stop, remove the containers, and remove named volumes:</p> <pre><code>$ docker compose down --volumes\n</code></pre>"},{"location":"#logs","title":"Logs","text":"<p>To view the logs of the services:</p> <pre><code>$ docker compose logs &lt;service-name&gt;\n</code></pre>"},{"location":"#interactive-shell","title":"Interactive Shell","text":"<p>To run an interactive shell in a service:</p> <pre><code># Or /bin/bash\n$ docker compose exec &lt;service-name&gt; /bin/sh\n</code></pre>"},{"location":"#database-migrations","title":"Database Migrations","text":"<p>The database migrations are managed using aerich, which is a tool specifically designed for Tortoise-ORM.</p>"},{"location":"#first-time-setup","title":"First Time Setup","text":""},{"location":"#configuration","title":"Configuration","text":"<p>To set up the initial config file and generate the root migrate location:</p> <pre><code>$ docker compose exec &lt;service-name&gt; aerich init -t app.db.TORTOISE_ORM\n</code></pre> <p>The <code>-t</code> flag specifies the module path to the Tortoise-ORM settings inside the <code>app.db</code> module. This will add a <code>tool.aerich</code> section to the <code>pyproject.toml</code> file.</p>"},{"location":"#initialize-database","title":"Initialize Database","text":"<p>To initialize the database:</p> <pre><code>$ docker compose exec &lt;service-name&gt; aerich init-db\n</code></pre> <p>This will create the tables in the database based on the models defined in <code>app/models/</code> along with the first migration file in the <code>migrations/</code> directory.</p>"},{"location":"#migration-workflow","title":"Migration Workflow","text":"<p>From this point on, since the local <code>migrations/</code> directory is synced with the <code>migrations/</code> directory on the container (for both <code>prod</code> &amp; <code>dev</code>), each time a change is made to the model, the following steps should be taken:</p> <ol> <li>In development mode, update the model in <code>app/models/</code> and run the following command to generate a new migration:</li> </ol> <pre><code>$ docker compose exec &lt;service-name&gt; aerich migrate --name &lt;migration-name&gt;\n</code></pre> <ol> <li>Apply the migration in development mode:</li> </ol> <pre><code>$ docker compose exec &lt;service-name&gt; aerich upgrade\n</code></pre> <ol> <li> <p>Run tests and any other necessary checks.</p> </li> <li> <p>Merge the changes to the <code>main</code> branch, which will trigger a deployment to the production environment. </p> </li> <li> <p>Once the changes are deployed, apply the migration in production via the heroku CLI:</p> </li> </ol> <pre><code>$ heroku run aerich upgrade --app &lt;app-name&gt;\n</code></pre> <p>See the aerich's usage documentation for more commands and details.</p>"},{"location":"#psql","title":"PSQL","text":"<p>The PostgreSQL database within the docker container can be accessed using psql, a terminal-based front-end to PostgreSQL.</p> <pre><code>$ docker compose exec -it &lt;service-name&gt; psql -U &lt;username&gt;\n</code></pre>"},{"location":"#connect","title":"Connect","text":"<p>To connect to a specific PostgreSQL database within the server:</p> <pre><code>$ \\c &lt;database-name&gt;\n</code></pre>"},{"location":"#list-tables","title":"List Tables","text":"<p>To list the tables in the connected database:</p> <pre><code>$ \\dt\n</code></pre>"},{"location":"#quit","title":"Quit","text":"<p>To quit the <code>psql</code> shell:</p> <pre><code>$ \\q\n</code></pre>"}]}